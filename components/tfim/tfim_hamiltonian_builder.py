"""
TFIM Hamiltonian Builder - QuantumForge V5 

æ¥æ”¶TFIMå‚æ•°ï¼Œç”ŸæˆQiskit SparsePauliOpå“ˆå¯†é¡¿é‡ä»£ç ã€‚ç®€å•ç‰ˆæœ¬ï¼šåªè¿”å›code+notesã€‚
"""

from typing import Dict, Any, List, Tuple

# å¯¼å…¥åŸºç±»
try:
    from ..base_component import BaseComponent
except ImportError:
    import sys
    import os
    sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
    from components.base_component import BaseComponent


class TFIMHamiltonianBuilder(BaseComponent):
    """TFIMå“ˆå¯†é¡¿é‡æ„å»ºå™¨ - åªç”Ÿæˆä»£ç """
    
    description = "Build TFIM Hamiltonian Qiskit code from TFIM parameters. Supports open/periodic boundary conditions."
    
    def execute(self, query: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """ç”ŸæˆTFIMå“ˆå¯†é¡¿é‡ä»£ç """
        # å‚æ•°è·å–
        num_qubits = int(params.get("num_qubits", 4))
        J = float(params.get("J", 1.0))
        h = float(params.get("h", 0.5))
        topology = params.get("topology", "linear")
        boundary = params.get("boundary_conditions", "open")
        
        # æ„å»ºPaulié¡¹
        pauli_terms = []
        
        # æ¨ªå‘ç£åœºé¡¹ï¼š-h * X_i
        for i in range(num_qubits):
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'X'
            pauli_terms.append((''.join(pauli_string), -h))
        
        # Isingè€¦åˆé¡¹ï¼š-J * Z_i * Z_{i+1}
        for i in range(num_qubits - 1):
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'Z'
            pauli_string[i + 1] = 'Z'
            pauli_terms.append((''.join(pauli_string), -J))
        
        # è¾¹ç•Œæ¡ä»¶ï¼šå‘¨æœŸè¾¹ç•Œæ·»åŠ é¦–å°¾è€¦åˆ
        if (boundary == "periodic" or topology == "ring") and num_qubits > 2:
            pauli_string = ['I'] * num_qubits
            pauli_string[0] = 'Z'
            pauli_string[-1] = 'Z'
            pauli_terms.append((''.join(pauli_string), -J))
        
        # ç”Ÿæˆä»£ç  - ä½¿ç”¨å‡½æ•°æ„å»ºï¼Œæ›´é€‚åˆå¤§å°ºå¯¸é—®é¢˜
        code = f'''# TFIM Hamiltonian Builder - Generated by QuantumForge V5
from qiskit.quantum_info import SparsePauliOp

def build_tfim_hamiltonian(num_qubits: int, J: float, h: float, boundary: str = "open"):
    """
    Build TFIM Hamiltonian efficiently for any system size.
    H = -J*âˆ‘ZZ - h*âˆ‘X
    """
    pauli_list = []
    
    # Transverse field terms: -h * X_i
    for i in range(num_qubits):
        pauli_string = ['I'] * num_qubits
        pauli_string[i] = 'X'
        pauli_list.append((''.join(pauli_string), -h))
    
    # Ising coupling terms: -J * Z_i * Z_{{i+1}}
    for i in range(num_qubits - 1):
        pauli_string = ['I'] * num_qubits
        pauli_string[i] = 'Z'
        pauli_string[i + 1] = 'Z'
        pauli_list.append((''.join(pauli_string), -J))
    
    # Periodic boundary condition
    if boundary == "periodic" and num_qubits > 2:
        pauli_string = ['I'] * num_qubits
        pauli_string[0] = 'Z'
        pauli_string[-1] = 'Z'
        pauli_list.append((''.join(pauli_string), -J))
    
    return SparsePauliOp.from_list(pauli_list)

# TFIM Parameters
num_qubits = {num_qubits}
J = {J}
h = {h}
boundary = "{boundary}"

# Build Hamiltonian
hamiltonian = build_tfim_hamiltonian(num_qubits, J, h, boundary)
print(f"TFIM Hamiltonian: {{num_qubits}} qubits, {{boundary}} boundary")'''

        # ç®€è¦æè¿°
        notes = f"TFIM Hamiltonian: {num_qubits} qubits, {boundary} boundary"
        
        return {"code": code, "notes": notes}


# æµ‹è¯•
if __name__ == "__main__":
    print("ğŸ§ª Testing TFIMHamiltonianBuilder...")
    
    builder = TFIMHamiltonianBuilder()
    
    test_cases = [
        {"num_qubits": 4, "J": 1.5, "h": 1.0, "boundary_conditions": "open"},
        {"num_qubits": 4, "J": 1.5, "h": 1.0, "boundary_conditions": "periodic"},
        {"num_qubits": 6, "J": 2.0, "h": 0.8, "topology": "ring"}
    ]
    
    for i, params in enumerate(test_cases, 1):
        print(f"\nğŸ§ª Test {i}: {params}")
        result = builder.execute("test", params)
        print(f"  Notes: {result['notes']}")
        print(f"  Code length: {len(result['code'])} chars")
    
    print("\nâœ… Simple and clean!")