"""
TFIM Hamiltonian Builder - QuantumForge V5 

接收TFIM参数，生成Qiskit SparsePauliOp哈密顿量代码。简单版本：只返回code+notes。
"""

from typing import Dict, Any, List, Tuple

# 导入基类
try:
    from ..base_component import BaseComponent
except ImportError:
    import sys
    import os
    sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
    from components.base_component import BaseComponent


class TFIMHamiltonianBuilder(BaseComponent):
    """TFIM哈密顿量构建器 - 只生成代码"""
    
    description = "Build TFIM Hamiltonian Qiskit code from TFIM parameters. Supports open/periodic boundary conditions."
    
    def execute(self, query: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """生成TFIM哈密顿量代码"""
        # 参数获取
        num_qubits = int(params.get("num_qubits", 4))
        J = float(params.get("J", 1.0))
        h = float(params.get("h", 0.5))
        topology = params.get("topology", "linear")
        boundary = params.get("boundary_conditions", "open")
        
        # 构建Pauli项
        pauli_terms = []
        
        # 横向磁场项：-h * X_i
        for i in range(num_qubits):
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'X'
            pauli_terms.append((''.join(pauli_string), -h))
        
        # Ising耦合项：-J * Z_i * Z_{i+1}
        for i in range(num_qubits - 1):
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'Z'
            pauli_string[i + 1] = 'Z'
            pauli_terms.append((''.join(pauli_string), -J))
        
        # 边界条件：周期边界添加首尾耦合
        if (boundary == "periodic" or topology == "ring") and num_qubits > 2:
            pauli_string = ['I'] * num_qubits
            pauli_string[0] = 'Z'
            pauli_string[-1] = 'Z'
            pauli_terms.append((''.join(pauli_string), -J))
        
        # 生成代码 - 使用函数构建，更适合大尺寸问题
        code = f'''# TFIM Hamiltonian Builder - Generated by QuantumForge V5
from qiskit.quantum_info import SparsePauliOp

def build_tfim_hamiltonian(num_qubits: int, J: float, h: float, boundary: str = "open"):
    """
    Build TFIM Hamiltonian efficiently for any system size.
    H = -J*∑ZZ - h*∑X
    """
    pauli_list = []
    
    # Transverse field terms: -h * X_i
    for i in range(num_qubits):
        pauli_string = ['I'] * num_qubits
        pauli_string[i] = 'X'
        pauli_list.append((''.join(pauli_string), -h))
    
    # Ising coupling terms: -J * Z_i * Z_{{i+1}}
    for i in range(num_qubits - 1):
        pauli_string = ['I'] * num_qubits
        pauli_string[i] = 'Z'
        pauli_string[i + 1] = 'Z'
        pauli_list.append((''.join(pauli_string), -J))
    
    # Periodic boundary condition
    if boundary == "periodic" and num_qubits > 2:
        pauli_string = ['I'] * num_qubits
        pauli_string[0] = 'Z'
        pauli_string[-1] = 'Z'
        pauli_list.append((''.join(pauli_string), -J))
    
    return SparsePauliOp.from_list(pauli_list)

# TFIM Parameters
num_qubits = {num_qubits}
J = {J}
h = {h}
boundary = "{boundary}"

# Build Hamiltonian
hamiltonian = build_tfim_hamiltonian(num_qubits, J, h, boundary)
print(f"TFIM Hamiltonian: {{num_qubits}} qubits, {{boundary}} boundary")'''

        # 简要描述
        notes = f"TFIM Hamiltonian: {num_qubits} qubits, {boundary} boundary"
        
        return {"code": code, "notes": notes}


# 测试
if __name__ == "__main__":
    print("🧪 Testing TFIMHamiltonianBuilder...")
    
    builder = TFIMHamiltonianBuilder()
    
    test_cases = [
        {"num_qubits": 4, "J": 1.5, "h": 1.0, "boundary_conditions": "open"},
        {"num_qubits": 4, "J": 1.5, "h": 1.0, "boundary_conditions": "periodic"},
        {"num_qubits": 6, "J": 2.0, "h": 0.8, "topology": "ring"}
    ]
    
    for i, params in enumerate(test_cases, 1):
        print(f"\n🧪 Test {i}: {params}")
        result = builder.execute("test", params)
        print(f"  Notes: {result['notes']}")
        print(f"  Code length: {len(result['code'])} chars")
    
    print("\n✅ Simple and clean!")