"""
ä»£ç æ¨¡æ¿ç³»ç»Ÿ - QuantumForge vNext

æä¾›ä»£ç ç”Ÿæˆçš„åŸºç¡€æ¨¡æ¿å’Œæ ¼å¼åŒ–å·¥å…·ã€‚
åŸºäºnew.mdç¬¬7èŠ‚å’Œç¬¬10èŠ‚çš„æ¨¡æ¿è§„æ ¼å®ç°ã€‚
"""

from typing import Dict, Any, List
from datetime import datetime


# =============================================================================
# æ¨¡æ¿å¸¸é‡
# =============================================================================

FILE_BANNER = '''"""
Quantum Computing Program
Generated by QuantumForge vNext

Query: {query}
Generated: {timestamp}
Algorithm: {algorithm}
"""

'''


MAIN_FUNCTION_TEMPLATE = '''def main({args}):
    """
    ä¸»æ‰§è¡Œå‡½æ•°
    
    Args:
{arg_docs}
    """
{param_aliases}
    
{function_body}
'''


ENTRY_POINT_TEMPLATE = '''
if __name__ == "__main__":
    main()
'''


# =============================================================================
# æ¨¡æ¿ç”Ÿæˆå‡½æ•°
# =============================================================================

def generate_file_banner(query: str, algorithm: str = "VQE") -> str:
    """
    ç”Ÿæˆæ–‡ä»¶å¤´æ³¨é‡Š
    
    Args:
        query: ç”¨æˆ·åŸå§‹æŸ¥è¯¢
        algorithm: ç®—æ³•ç±»å‹
        
    Returns:
        æ ¼å¼åŒ–çš„æ–‡ä»¶å¤´æ³¨é‡Š
    """
    return FILE_BANNER.format(
        query=query,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        algorithm=algorithm
    )


def main_wrapper(body: str, args_spec: Dict[str, Any]) -> str:
    """
    ç”Ÿæˆmainå‡½æ•°åŒ…è£…
    
    Args:
        body: å‡½æ•°ä½“å†…å®¹
        args_spec: å‚æ•°è§„æ ¼å­—å…¸
        
    Returns:
        å®Œæ•´çš„mainå‡½æ•°ä»£ç 
    """
    # ç”Ÿæˆå‚æ•°åˆ—è¡¨ï¼ˆæŒ‰Pythonè¯­æ³•è¦æ±‚æ’åºï¼šæ— é»˜è®¤å€¼åœ¨å‰ï¼Œæœ‰é»˜è®¤å€¼åœ¨åï¼‰
    required_args = []  # æ— é»˜è®¤å€¼å‚æ•°
    optional_args = []  # æœ‰é»˜è®¤å€¼å‚æ•°
    arg_docs_list = []
    
    for param_name, param_info in args_spec.items():
        if isinstance(param_info, dict):
            param_type = param_info.get("type", "Any")
            default_value = param_info.get("default")
            description = param_info.get("description", f"Parameter {param_name}")
            
            if default_value is not None:
                optional_args.append(f"{param_name}: {param_type} = {repr(default_value)}")
            else:
                # ä¸ºæ²¡æœ‰é»˜è®¤å€¼çš„å‚æ•°æä¾›åˆç†é»˜è®¤å€¼
                if param_type == "Any":
                    optional_args.append(f"{param_name}: {param_type} = None")
                elif param_type == "int":
                    optional_args.append(f"{param_name}: {param_type} = 0")
                elif param_type == "float":
                    optional_args.append(f"{param_name}: {param_type} = 0.0")
                elif param_type == "str":
                    optional_args.append(f"{param_name}: {param_type} = ''")
                else:
                    optional_args.append(f"{param_name}: {param_type} = None")
                
            arg_docs_list.append(f"        {param_name}: {description}")
        else:
            # ç®€å•æ ¼å¼ï¼šå‚æ•°å -> é»˜è®¤å€¼
            if param_info is not None:
                optional_args.append(f"{param_name} = {repr(param_info)}")
            else:
                required_args.append(param_name)
            arg_docs_list.append(f"        {param_name}: Parameter {param_name}")
    
    # åˆå¹¶å‚æ•°åˆ—è¡¨ï¼šå¿…éœ€å‚æ•° + å¯é€‰å‚æ•°
    all_args = required_args + optional_args
    args_str = ", ".join(all_args) if all_args else ""
    arg_docs_str = "\n".join(arg_docs_list) if arg_docs_list else "        No parameters"
    
    return MAIN_FUNCTION_TEMPLATE.format(
        args=args_str,
        arg_docs=arg_docs_str,
        param_aliases="",  # å°†ç”±å‚æ•°åˆ«åç³»ç»Ÿå¡«å……
        function_body=body
    )


def emit_entry(main_name: str = "main") -> str:
    """
    ç”Ÿæˆç¨‹åºå…¥å£ç‚¹
    
    Args:
        main_name: ä¸»å‡½æ•°åç§°
        
    Returns:
        å…¥å£ç‚¹ä»£ç 
    """
    if main_name != "main":
        return f'''
if __name__ == "__main__":
    {main_name}()
'''
    return ENTRY_POINT_TEMPLATE


def generate_param_aliases(param_map: Dict[str, str]) -> str:
    """
    ç”Ÿæˆå‚æ•°åˆ«åå½’ä¸€åŒ–ä»£ç ç‰‡æ®µ - å·²ç¦ç”¨ä»¥ä¿®å¤è¯­æ³•é”™è¯¯
    
    Args:
        param_map: åˆ«åæ˜ å°„å­—å…¸ {"num_qubits": "n", "h_x": "hx"}
        
    Returns:
        ç©ºå­—ç¬¦ä¸²ï¼ˆå·²ç¦ç”¨åˆ«åç”Ÿæˆï¼‰
    """
    # ç¦ç”¨åˆ«åç”Ÿæˆï¼Œå› ä¸ºä¼šäº§ç”Ÿæ— æ•ˆè¯­æ³•
    # å‚æ•°åˆ«ååº”è¯¥åœ¨mainå‡½æ•°ç­¾åä¸­ç›´æ¥ä½¿ç”¨æ ‡å‡†åç§°
    return ""


def format_code_sections(sections: Dict[str, List[str]]) -> str:
    """
    æ ¼å¼åŒ–ä»£ç æ®µè½
    
    Args:
        sections: ä»£ç æ®µè½å­—å…¸ {"helpers": [...], "definitions": [...]}
        
    Returns:
        æ ¼å¼åŒ–çš„ä»£ç å­—ç¬¦ä¸²
    """
    formatted_sections = []
    
    # å¤„ç†helpers
    if sections.get("helpers"):
        formatted_sections.append("# Helper Functions")
        formatted_sections.extend(sections["helpers"])
        formatted_sections.append("")  # ç©ºè¡Œ
    
    # å¤„ç†definitions
    if sections.get("definitions"):
        formatted_sections.append("# Definitions")
        formatted_sections.extend(sections["definitions"])
        formatted_sections.append("")  # ç©ºè¡Œ
    
    return "\n".join(formatted_sections)


def create_complete_program(
    query: str,
    algorithm: str,
    imports: List[str],
    helpers: List[str],
    definitions: List[str],
    main_body: str,
    args_spec: Dict[str, Any] = None,
    param_aliases: Dict[str, str] = None
) -> str:
    """
    åˆ›å»ºå®Œæ•´çš„Pythonç¨‹åº
    
    Args:
        query: ç”¨æˆ·æŸ¥è¯¢
        algorithm: ç®—æ³•ç±»å‹
        imports: importè¯­å¥åˆ—è¡¨
        helpers: è¾…åŠ©å‡½æ•°åˆ—è¡¨
        definitions: å®šä¹‰åˆ—è¡¨
        main_body: mainå‡½æ•°ä½“
        args_spec: å‚æ•°è§„æ ¼
        param_aliases: å‚æ•°åˆ«åæ˜ å°„
        
    Returns:
        å®Œæ•´çš„Pythonç¨‹åºä»£ç 
    """
    program_parts = []
    
    # 1. æ–‡ä»¶å¤´æ³¨é‡Š
    banner = generate_file_banner(query, algorithm)
    program_parts.append(banner)
    
    # 2. Importè¯­å¥ï¼ˆå‡è®¾å·²ç»æ ‡å‡†åŒ–ï¼‰
    if imports:
        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ·»åŠ typingå¯¼å…¥
        typing_needed = 'Any' in str(args_spec) if args_spec else False
        if typing_needed and not any('from typing import' in imp for imp in imports):
            imports.insert(0, "from typing import Any")
        
        program_parts.extend(imports)
        program_parts.append("")  # ç©ºè¡Œ
    
    # 3. ä»£ç æ®µè½
    sections = {
        "helpers": helpers,
        "definitions": definitions
    }
    formatted_sections = format_code_sections(sections)
    if formatted_sections.strip():
        program_parts.append(formatted_sections)
    
    # 4. å‚æ•°åˆ«åå¤„ç†
    alias_code = ""
    if param_aliases:
        alias_code = generate_param_aliases(param_aliases)
    
    # 5. Mainå‡½æ•°
    main_func = main_wrapper(alias_code + main_body, args_spec or {})
    program_parts.append(main_func)
    
    # 6. å…¥å£ç‚¹
    entry = emit_entry()
    program_parts.append(entry)
    
    return "\n".join(program_parts)


# =============================================================================
# æµ‹è¯•ä»£ç 
# =============================================================================

if __name__ == "__main__":
    print("ğŸ§ª Testing CodeTemplates...")
    
    # æµ‹è¯•æ•°æ®
    test_query = "è®¡ç®—8æ¯”ç‰¹TFIMåŸºæ€èƒ½é‡ï¼Œä½¿ç”¨VQEç®—æ³•"
    test_imports = [
        "import numpy as np",
        "from qiskit import QuantumCircuit", 
        "from qiskit.quantum_info import SparsePauliOp"
    ]
    test_helpers = [
        "def build_tfim_h(n, hx, j, boundary='periodic'):",
        "    # TFIM Hamiltonianæ„å»º",
        "    return SparsePauliOp.from_list([...])"
    ]
    test_main_body = '''    # æ„å»ºTFIM Hamiltonian
    H = build_tfim_h(n=n, hx=hx, j=j, boundary=boundary)
    
    # åˆ›å»ºVQEç”µè·¯
    ansatz = tfim_hea(n=n, reps=reps)
    
    # è¿è¡ŒVQE
    vqe = VQE(estimator, ansatz, optimizer)
    result = vqe.compute_minimum_eigenvalue(H)
    energy = float(result.eigenvalue.real)
    
    print(f"TFIM Ground State Energy: {energy:.6f}")'''
    
    test_args = {
        "n": {"type": "int", "default": 8, "description": "Number of qubits"},
        "hx": {"type": "float", "default": 1.0, "description": "Transverse field strength"},
        "j": {"type": "float", "default": 1.0, "description": "Coupling strength"}
    }
    
    test_aliases = {"num_qubits": "n", "h_x": "hx"}
    
    # ç”Ÿæˆå®Œæ•´ç¨‹åº
    complete_program = create_complete_program(
        query=test_query,
        algorithm="VQE",
        imports=test_imports,
        helpers=test_helpers,
        definitions=[],
        main_body=test_main_body,
        args_spec=test_args,
        param_aliases=test_aliases
    )
    
    print("ğŸ“„ ç”Ÿæˆçš„å®Œæ•´ç¨‹åº:")
    print("-" * 50)
    print(complete_program)
    print("-" * 50)
    
    print("âœ… CodeTemplates æµ‹è¯•é€šè¿‡ï¼")