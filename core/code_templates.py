"""
代码模板系统 - QuantumForge vNext

提供代码生成的基础模板和格式化工具。
基于new.md第7节和第10节的模板规格实现。
"""

from typing import Dict, Any, List
from datetime import datetime


# =============================================================================
# 模板常量
# =============================================================================

FILE_BANNER = '''"""
Quantum Computing Program
Generated by QuantumForge vNext

Query: {query}
Generated: {timestamp}
Algorithm: {algorithm}
"""

'''


MAIN_FUNCTION_TEMPLATE = '''def main({args}):
    """
    主执行函数
    
    Args:
{arg_docs}
    """
{param_aliases}
    
{function_body}
'''


ENTRY_POINT_TEMPLATE = '''
if __name__ == "__main__":
    main()
'''


# =============================================================================
# 模板生成函数
# =============================================================================

def generate_file_banner(query: str, algorithm: str = "VQE") -> str:
    """
    生成文件头注释
    
    Args:
        query: 用户原始查询
        algorithm: 算法类型
        
    Returns:
        格式化的文件头注释
    """
    return FILE_BANNER.format(
        query=query,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        algorithm=algorithm
    )


def main_wrapper(body: str, args_spec: Dict[str, Any]) -> str:
    """
    生成main函数包装
    
    Args:
        body: 函数体内容
        args_spec: 参数规格字典
        
    Returns:
        完整的main函数代码
    """
    # 生成参数列表（按Python语法要求排序：无默认值在前，有默认值在后）
    required_args = []  # 无默认值参数
    optional_args = []  # 有默认值参数
    arg_docs_list = []
    
    for param_name, param_info in args_spec.items():
        if isinstance(param_info, dict):
            param_type = param_info.get("type", "Any")
            default_value = param_info.get("default")
            description = param_info.get("description", f"Parameter {param_name}")
            
            if default_value is not None:
                optional_args.append(f"{param_name}: {param_type} = {repr(default_value)}")
            else:
                # 为没有默认值的参数提供合理默认值
                if param_type == "Any":
                    optional_args.append(f"{param_name}: {param_type} = None")
                elif param_type == "int":
                    optional_args.append(f"{param_name}: {param_type} = 0")
                elif param_type == "float":
                    optional_args.append(f"{param_name}: {param_type} = 0.0")
                elif param_type == "str":
                    optional_args.append(f"{param_name}: {param_type} = ''")
                else:
                    optional_args.append(f"{param_name}: {param_type} = None")
                
            arg_docs_list.append(f"        {param_name}: {description}")
        else:
            # 简单格式：参数名 -> 默认值
            if param_info is not None:
                optional_args.append(f"{param_name} = {repr(param_info)}")
            else:
                required_args.append(param_name)
            arg_docs_list.append(f"        {param_name}: Parameter {param_name}")
    
    # 合并参数列表：必需参数 + 可选参数
    all_args = required_args + optional_args
    args_str = ", ".join(all_args) if all_args else ""
    arg_docs_str = "\n".join(arg_docs_list) if arg_docs_list else "        No parameters"
    
    return MAIN_FUNCTION_TEMPLATE.format(
        args=args_str,
        arg_docs=arg_docs_str,
        param_aliases="",  # 将由参数别名系统填充
        function_body=body
    )


def emit_entry(main_name: str = "main") -> str:
    """
    生成程序入口点
    
    Args:
        main_name: 主函数名称
        
    Returns:
        入口点代码
    """
    if main_name != "main":
        return f'''
if __name__ == "__main__":
    {main_name}()
'''
    return ENTRY_POINT_TEMPLATE


def generate_param_aliases(param_map: Dict[str, str]) -> str:
    """
    生成参数别名归一化代码片段 - 已禁用以修复语法错误
    
    Args:
        param_map: 别名映射字典 {"num_qubits": "n", "h_x": "hx"}
        
    Returns:
        空字符串（已禁用别名生成）
    """
    # 禁用别名生成，因为会产生无效语法
    # 参数别名应该在main函数签名中直接使用标准名称
    return ""


def format_code_sections(sections: Dict[str, List[str]]) -> str:
    """
    格式化代码段落
    
    Args:
        sections: 代码段落字典 {"helpers": [...], "definitions": [...]}
        
    Returns:
        格式化的代码字符串
    """
    formatted_sections = []
    
    # 处理helpers
    if sections.get("helpers"):
        formatted_sections.append("# Helper Functions")
        formatted_sections.extend(sections["helpers"])
        formatted_sections.append("")  # 空行
    
    # 处理definitions
    if sections.get("definitions"):
        formatted_sections.append("# Definitions")
        formatted_sections.extend(sections["definitions"])
        formatted_sections.append("")  # 空行
    
    return "\n".join(formatted_sections)


def create_complete_program(
    query: str,
    algorithm: str,
    imports: List[str],
    helpers: List[str],
    definitions: List[str],
    main_body: str,
    args_spec: Dict[str, Any] = None,
    param_aliases: Dict[str, str] = None
) -> str:
    """
    创建完整的Python程序
    
    Args:
        query: 用户查询
        algorithm: 算法类型
        imports: import语句列表
        helpers: 辅助函数列表
        definitions: 定义列表
        main_body: main函数体
        args_spec: 参数规格
        param_aliases: 参数别名映射
        
    Returns:
        完整的Python程序代码
    """
    program_parts = []
    
    # 1. 文件头注释
    banner = generate_file_banner(query, algorithm)
    program_parts.append(banner)
    
    # 2. Import语句（假设已经标准化）
    if imports:
        # 检查是否需要添加typing导入
        typing_needed = 'Any' in str(args_spec) if args_spec else False
        if typing_needed and not any('from typing import' in imp for imp in imports):
            imports.insert(0, "from typing import Any")
        
        program_parts.extend(imports)
        program_parts.append("")  # 空行
    
    # 3. 代码段落
    sections = {
        "helpers": helpers,
        "definitions": definitions
    }
    formatted_sections = format_code_sections(sections)
    if formatted_sections.strip():
        program_parts.append(formatted_sections)
    
    # 4. 参数别名处理
    alias_code = ""
    if param_aliases:
        alias_code = generate_param_aliases(param_aliases)
    
    # 5. Main函数
    main_func = main_wrapper(alias_code + main_body, args_spec or {})
    program_parts.append(main_func)
    
    # 6. 入口点
    entry = emit_entry()
    program_parts.append(entry)
    
    return "\n".join(program_parts)


# =============================================================================
# 测试代码
# =============================================================================

if __name__ == "__main__":
    print("🧪 Testing CodeTemplates...")
    
    # 测试数据
    test_query = "计算8比特TFIM基态能量，使用VQE算法"
    test_imports = [
        "import numpy as np",
        "from qiskit import QuantumCircuit", 
        "from qiskit.quantum_info import SparsePauliOp"
    ]
    test_helpers = [
        "def build_tfim_h(n, hx, j, boundary='periodic'):",
        "    # TFIM Hamiltonian构建",
        "    return SparsePauliOp.from_list([...])"
    ]
    test_main_body = '''    # 构建TFIM Hamiltonian
    H = build_tfim_h(n=n, hx=hx, j=j, boundary=boundary)
    
    # 创建VQE电路
    ansatz = tfim_hea(n=n, reps=reps)
    
    # 运行VQE
    vqe = VQE(estimator, ansatz, optimizer)
    result = vqe.compute_minimum_eigenvalue(H)
    energy = float(result.eigenvalue.real)
    
    print(f"TFIM Ground State Energy: {energy:.6f}")'''
    
    test_args = {
        "n": {"type": "int", "default": 8, "description": "Number of qubits"},
        "hx": {"type": "float", "default": 1.0, "description": "Transverse field strength"},
        "j": {"type": "float", "default": 1.0, "description": "Coupling strength"}
    }
    
    test_aliases = {"num_qubits": "n", "h_x": "hx"}
    
    # 生成完整程序
    complete_program = create_complete_program(
        query=test_query,
        algorithm="VQE",
        imports=test_imports,
        helpers=test_helpers,
        definitions=[],
        main_body=test_main_body,
        args_spec=test_args,
        param_aliases=test_aliases
    )
    
    print("📄 生成的完整程序:")
    print("-" * 50)
    print(complete_program)
    print("-" * 50)
    
    print("✅ CodeTemplates 测试通过！")