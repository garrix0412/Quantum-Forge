"""
Quantum Computing Program
Generated by QuantumForge V5

Original Query: Create a VQE simulation for 6-qubit Heisenberg model with real amplitudes ansatz and L_BFGS_B optimization
Generated Time: 2025-08-20 16:34:50
"""

# Complete quantum computing program for VQE simulation of 6-qubit Heisenberg model

from qiskit.quantum_info import SparsePauliOp
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit_algorithms import VQE
from qiskit_algorithms.optimizers import SLSQP
from qiskit.primitives import StatevectorEstimator
import numpy as np

# Heisenberg Hamiltonian Builder
def build_heisenberg_hamiltonian(num_qubits: int, Jx: float, Jy: float, Jz: float, 
                                 hx: float = 0.0, hy: float = 0.0, hz: float = 0.0, 
                                 boundary: str = "open"):
    pauli_list = []
    coupling_terms = num_qubits - 1 if boundary == "open" else num_qubits
    
    for i in range(coupling_terms):
        j = (i + 1) % num_qubits
        
        if abs(Jx) > 1e-12:
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'X'
            pauli_string[j] = 'X'
            pauli_list.append((''.join(pauli_string), Jx))
        
        if abs(Jy) > 1e-12:
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'Y'
            pauli_string[j] = 'Y'
            pauli_list.append((''.join(pauli_string), Jy))
        
        if abs(Jz) > 1e-12:
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'Z'
            pauli_string[j] = 'Z'
            pauli_list.append((''.join(pauli_string), Jz))
    
    for i in range(num_qubits):
        if abs(hx) > 1e-12:
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'X'
            pauli_list.append((''.join(pauli_string), hx))
        
        if abs(hy) > 1e-12:
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'Y'
            pauli_list.append((''.join(pauli_string), hy))
        
        if abs(hz) > 1e-12:
            pauli_string = ['I'] * num_qubits
            pauli_string[i] = 'Z'
            pauli_list.append((''.join(pauli_string), hz))
    
    return SparsePauliOp.from_list(pauli_list)

# Heisenberg VQE Ansatz Circuit
def create_heisenberg_vqe_ansatz(num_qubits: int, depth: int) -> tuple:
    qc = QuantumCircuit(num_qubits)
    parameters = []
    
    for layer in range(depth):
        coupling_pairs = num_qubits - 1
        
        for i in range(coupling_pairs):
            j = (i + 1) % num_qubits
            
            theta_xx = Parameter(f'xx_{layer}_{i}')
            parameters.append(theta_xx)
            qc.rxx(theta_xx, i, j)
            
            theta_yy = Parameter(f'yy_{layer}_{i}')
            parameters.append(theta_yy)
            qc.ryy(theta_yy, i, j)
            
            theta_zz = Parameter(f'zz_{layer}_{i}')
            parameters.append(theta_zz)
            qc.rzz(theta_zz, i, j)
        
        for i in range(num_qubits):
            if abs(hx) > 1e-10:
                theta_x = Parameter(f'rx_{layer}_{i}')
                parameters.append(theta_x)
                qc.rx(theta_x, i)
            
            if abs(hy) > 1e-10:
                theta_y = Parameter(f'ry_{layer}_{i}')
                parameters.append(theta_y)
                qc.ry(theta_y, i)
            
            if abs(hz) > 1e-10:
                theta_z = Parameter(f'rz_{layer}_{i}')
                parameters.append(theta_z)
                qc.rz(theta_z, i)

    return qc, parameters

def main():
    # Heisenberg Model Parameters
    num_qubits = 6
    Jx, Jy, Jz = 1.0, 1.0, 1.0 
    hx, hy, hz = 0.0, 0.0, 0.0  
    boundary = "open"
    depth = 3

    # Build Hamiltonian
    hamiltonian = build_heisenberg_hamiltonian(num_qubits, Jx, Jy, Jz, hx, hy, hz, boundary)
    print(f"Heisenberg Hamiltonian built: {hamiltonian}")

    # Create the ansatz
    ansatz_circuit, theta_params = create_heisenberg_vqe_ansatz(num_qubits, depth)
    print(f"Heisenberg VQE ansatz created with {len(theta_params)} parameters")

    # Configure optimizer
    optimizer = SLSQP(maxiter=200, ftol=1e-06)
    print(f"Configured SLSQP optimizer: {optimizer.settings}")

    # Create statevector estimator
    estimator = StatevectorEstimator()
    print("Statevector estimator configured for VQE")

    # Create VQE instance
    vqe = VQE(estimator=estimator, ansatz=ansatz_circuit, optimizer=optimizer)
    print(f"VQE configured with SLSQP optimizer")

if __name__ == "__main__":
    main()