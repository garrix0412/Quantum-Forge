"""
TFIM Model Generator

生成TFIM (Transverse Field Ising Model) 模型的基础参数和初始化代码。
"""

import sys
import os

# 添加父目录到路径以导入BaseTool
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from typing import Dict, Any
from base_tool import BaseTool


class TFIMModelGenerator(BaseTool):
    """
    TFIM模型生成器
    
    功能:
    - 根据用户查询和上下文分析TFIM模型需求
    - 调用LLM提取关键参数信息
    - 生成TFIM模型的基础参数代码
    """
    
    def __init__(self):
        super().__init__()
        
    def execute(self, context: str) -> Dict[str, Any]:
        """
        执行TFIM模型生成
        
        Args:
            context: 从Memory获取的上下文信息
            
        Returns:
            包含TFIM模型参数代码的结果
        """
        try:
            # 调用LLM分析上下文并提取TFIM参数
            parameters = self._extract_tfim_parameters(context)
            
            # 生成TFIM模型代码
            code = self._generate_tfim_code(parameters)
            
            return {
                "code": code,
                "parameters": parameters,
                "notes": f"Generated TFIM model with {parameters['num_qubits']} qubits"
            }
            
        except Exception as e:
            return {
                "error": str(e),
                "code": "",
                "notes": f"Failed to generate TFIM model: {str(e)}"
            }
    
    def _extract_tfim_parameters(self, context: str) -> Dict[str, Any]:
        """
        使用LLM从上下文中提取TFIM参数
        
        Args:
            context: 上下文信息
            
        Returns:
            TFIM参数字典
        """
        # 导入LLM调用函数
        core_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'core')
        if core_path not in sys.path:
            sys.path.append(core_path)
        from llm_engine import call_llm
        
        prompt = f"""
Based on the following context, extract TFIM (Transverse Field Ising Model) parameters:

{context}

Please analyze the user's request and provide appropriate TFIM parameters in JSON format:

{{
    "num_qubits": <number of qubits>,
    "coupling_strength": <J coupling strength>,
    "field_strength": <h transverse field strength>,
    "topology": <"linear" or "circular" or "2d_grid">,
    "boundary_conditions": <"open" or "periodic">
}}

Rules:
- If not specified, use reasonable defaults
- num_qubits: default 4, typical range 2-10
- coupling_strength: default 1.0, typical range 0.5-2.0  
- field_strength: default 1.0, typical range 0.5-2.0
- topology: default "linear"
- boundary_conditions: default "open"

Respond with ONLY the JSON object:"""

        try:
            response = call_llm(prompt, temperature=0.1)
            
            # 尝试解析JSON响应
            import json
            
            # 清理响应，提取JSON部分
            response = response.strip()
            if '```' in response:
                # 如果有代码块标记，提取其中的内容
                start = response.find('{')
                end = response.rfind('}') + 1
                if start != -1 and end > start:
                    response = response[start:end]
            
            parameters = json.loads(response)
            
            # 验证参数并设置默认值
            parameters = self._validate_parameters(parameters)
            
            return parameters
            
        except Exception as e:
            print(f"⚠️ Failed to extract parameters via LLM: {e}")
            
            # 回退到默认参数
            return self._get_default_parameters()
    
    def _validate_parameters(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """验证并修正参数"""
        validated = {}
        
        # 验证量子比特数
        validated['num_qubits'] = max(2, min(20, params.get('num_qubits', 4)))
        
        # 验证耦合强度
        validated['coupling_strength'] = max(0.1, min(5.0, params.get('coupling_strength', 1.0)))
        
        # 验证磁场强度
        validated['field_strength'] = max(0.1, min(5.0, params.get('field_strength', 1.0)))
        
        # 验证拓扑
        topology = params.get('topology', 'linear')
        if topology not in ['linear', 'circular', '2d_grid']:
            topology = 'linear'
        validated['topology'] = topology
        
        # 验证边界条件
        boundary = params.get('boundary_conditions', 'open')
        if boundary not in ['open', 'periodic']:
            boundary = 'open'
        validated['boundary_conditions'] = boundary
        
        return validated
    
    def _get_default_parameters(self) -> Dict[str, Any]:
        """获取默认TFIM参数"""
        return {
            "num_qubits": 4,
            "coupling_strength": 1.0,
            "field_strength": 1.0,
            "topology": "linear",
            "boundary_conditions": "open"
        }
    
    def _generate_tfim_code(self, parameters: Dict[str, Any]) -> str:
        """
        生成TFIM模型代码
        
        Args:
            parameters: TFIM参数
            
        Returns:
            生成的Python代码
        """
        code = f"""# TFIM (Transverse Field Ising Model) Parameters
# Generated by QuantumForge V4

import numpy as np

# Model Configuration
num_qubits = {parameters['num_qubits']}
coupling_strength = {parameters['coupling_strength']}  # J parameter
field_strength = {parameters['field_strength']}        # h parameter
topology = "{parameters['topology']}"
boundary_conditions = "{parameters['boundary_conditions']}"

# Model Description
model_info = {{
    "model_type": "TFIM",
    "num_qubits": num_qubits,
    "coupling_strength": coupling_strength,
    "field_strength": field_strength,
    "topology": topology,
    "boundary_conditions": boundary_conditions
}}

print(f"TFIM Model: {{num_qubits}} qubits, J={{coupling_strength}}, h={{field_strength}}")
print(f"Topology: {{topology}}, Boundary: {{boundary_conditions}}")
"""
        
        return code


# 测试代码
if __name__ == "__main__":
    tool = TFIMModelGenerator()
    
    # 测试上下文
    test_context = """
Original Query: Generate a 6-qubit TFIM model with strong coupling
Current Step: 1

Execution History:
Step 1: TFIMModelGenerator
"""
    
    result = tool.execute(test_context)
    print("Tool Result:")
    print(f"Parameters: {result.get('parameters', 'None')}")
    print(f"Code:\\n{result.get('code', 'None')}")
    print(f"Notes: {result.get('notes', 'None')}")